####################################################
# DVrouter.py
# Name:
# HUID:
#####################################################

from router import Router
import json 
from packet import Packet


class DVrouter(Router):
    """Distance vector routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here
        self.infinity = 16

        self.neighbors = {}  # port -> (addr, cost)
        self.dv = {self.addr: 0}
        self.forwarding_table = {}  # destination -> port
        self.received_vectors = {}
        # pass

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            dst = packet.dst_addr
            if dst in self.forwarding_table:
                out_port = self.forwarding_table[dst]
                self.send(out_port, packet)
            # pass
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the received distance vector is different
            #   update the local copy of the distance vector
            #   update the distance vector of this router
            #   update the forwarding table
            #   broadcast the distance vector of this router to neighbors
            try:
                vector = json.loads(packet.content)
            except:
                return
            sender = packet.src_addr
            if self.received_vectors.get(sender) != vector:
                self.received_vectors[sender] = vector
                if self.update_distance_vector():
                    self.broadcast_distance_vector()
            # pass

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors
        self.neighbors[port] = (endpoint, cost)
        self.received_vectors[endpoint] = {endpoint: 0}
        if self.update_distance_vector():
            self.broadcast_distance_vector()
        # pass

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors
        if port in self.neighbors:
            neighbor_addr, _ = self.neighbors.pop(port)
            self.received_vectors.pop(neighbor_addr, None)
            if self.update_distance_vector():
                self.broadcast_distance_vector()
        # pass

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the distance vector of this router to neighbors
            self.broadcast_distance_vector()
            # pass

    def broadcast_distance_vector(self):
        content = json.dumps(self.dv)
        for port, (neighbor, _) in self.neighbors.items():
            packet = Packet(Packet.ROUTING, self.addr, neighbor, content)
            self.send(port, packet)

    def update_distance_vector(self):
        updated = False
        new_dv = {self.addr: 0}
        new_forwarding = {}

        for dest in set().union(*self.received_vectors.values(), [self.addr]):
            if dest == self.addr:
                continue
            best_cost = self.infinity
            best_port = None
            for port, (neighbor, cost) in self.neighbors.items():
                neighbor_vector = self.received_vectors.get(neighbor, {})
                if dest in neighbor_vector:
                    total_cost = cost + neighbor_vector[dest]
                    if total_cost < best_cost:
                        best_cost = total_cost
                        best_port = port
            if best_cost < self.infinity:
                new_dv[dest] = best_cost
                new_forwarding[dest] = best_port

        changed_costs = new_dv != self.dv
        changed_next_hops = any(
            self.forwarding_table.get(dest) != new_forwarding.get(dest)
            for dest in new_forwarding
        )
        if changed_costs or changed_next_hops:
            self.dv = new_dv
            self.forwarding_table = new_forwarding
            updated = True

        return updated

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return (
            f"DVrouter(addr={self.addr}, \n"
            f"neighbors={self.neighbors}, \n"
            f"dv={self.dv}, \n"
            f"forwarding_table={self.forwarding_table}, \n"
            f"received_vectors={self.received_vectors})"
        )

